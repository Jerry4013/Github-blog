---
title:  "LeetCode(64) -- 341, "
tags: LeetCode
---

## P341. Flatten Nested List Iterator (Medium)

Given a nested list of integers, implement an iterator to flatten it.

Each element is either an integer, or a list -- whose elements may also be integers or other lists.

```
Input: [[1,1],2,[1,1]]
Output: [1,1,2,1,1]
Explanation: By calling next repeatedly until hasNext returns false,
             the order of elements returned by next should be: [1,1,2,1,1].
```

### 我的思路

在constructor里，通过递归把list变成一个整数的list，然后用这个list的iterator来遍历。

### 我的代码

```java
public class NestedIterator {

    List<Integer> integerList;
    Iterator<Integer> iterator;

    public NestedIterator(List<NestedInteger> nestedList) {
        integerList = new ArrayList<>();
        for (NestedInteger nestedInteger : nestedList) {
            if (nestedInteger.isInteger()) {
                integerList.add(nestedInteger.getInteger());
            } else {
                NestedIterator nestedIterator = new NestedIterator(nestedInteger.getList());
                while (nestedIterator.hasNext()) {
                    integerList.add(nestedIterator.next());
                }
            }
        }
        iterator = integerList.iterator();
    }

    public Integer next() {
        return iterator.next();
    }

    public boolean hasNext() {
        return iterator.hasNext();
    }
}
```
68%

### 最优解

```java
public class NestedIterator implements Iterator<Integer> {
    NestedInteger innerInteger = null;
    Iterator<Integer> inner = null;
    Iterator<NestedInteger> out;
    public NestedIterator(List<NestedInteger> nestedList) {
        out = nestedList.iterator();
    }

    @Override
    public Integer next() {
        if (null != innerInteger) {
            Integer r = innerInteger.getInteger();
            innerInteger = null;
            return r;
        }
        return inner.next();
    }

    @Override
    public boolean hasNext() {
        if (null != innerInteger && innerInteger.isInteger()) return true;
        if (null != inner && inner.hasNext()) return true;
        while(out.hasNext()) {
            NestedInteger next = out.next();
            if (next.isInteger()) {
                innerInteger = next;
                inner = null;
                return true;
            } else {
                innerInteger = null;
                inner = new NestedIterator(next.getList());
                if(inner.hasNext()) return true;
            }
        }
        inner = null;
        return false;
    }
}
```
读这个答案时，需要先读hasNext()方法，否则说不通。该方法用了list的iterator方法来遍历，如果是整数，就不新建任何东西了，直接把inner设置为null。可能这就是比我的方法快的原因。

## P.  (Medium)



### 我的思路



### 我的代码

```java

```



### 最优解

```java

```




## P.  (Medium)



### 我的思路



### 我的代码

```java

```


### 最优解

```java

```




## P.  (Medium)


### 我的思路



### 我的代码

```java

```


### 最优解

```java

```



### 答案

```java

```

## P.  (Medium)



### 我的思路



### 最优解

```java

```


### 答案：




